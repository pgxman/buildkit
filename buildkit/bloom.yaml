---
apiVersion: v1
name: bloom
repository: https://github.com/postgres/postgres
description: bloom access method - signature file based index
license: PostgreSQL
arch:
- amd64
- arm64
maintainers:
- name: Jonathan Dance
  email: jd@hydra.so
- name: Owen Ou
  email: o@hydra.so
build:
  main:
  - name: Build bloom
    run: |
      cd contrib/bloom
      make
      DESTDIR=${DESTDIR} make install
overrides:
  pgVersions:
    '16':
      source: https://ftp.postgresql.org/pub/source/v16.1/postgresql-16.1.tar.gz
      version: 16.1.0
      homepage: https://www.postgresql.org/docs/16/bloom.html
      readme: |
        For formatted documentation, please see https://www.postgresql.org/docs/16/bloom.html.

        ```
           #[1]F.6. basic_archive -- an example WAL archive module
           [2]F.8. btree_gin -- GIN operator classes with B-tree behavior

           F.7. bloom -- bloom filter index access method
           [3]Prev  [4]Up Appendix F. Additional Supplied Modules and Extensions
           [5]Home  [6]Next
             __________________________________________________________________

        F.7. bloom -- bloom filter index access method [7]#

           [8]F.7.1. Parameters
           [9]F.7.2. Examples
           [10]F.7.3. Operator Class Interface
           [11]F.7.4. Limitations
           [12]F.7.5. Authors

           bloom provides an index access method based on [13]Bloom filters.

           A Bloom filter is a space-efficient data structure that is used to test
           whether an element is a member of a set. In the case of an index access
           method, it allows fast exclusion of non-matching tuples via signatures
           whose size is determined at index creation.

           A signature is a lossy representation of the indexed attribute(s), and
           as such is prone to reporting false positives; that is, it may be
           reported that an element is in the set, when it is not. So index search
           results must always be rechecked using the actual attribute values from
           the heap entry. Larger signatures reduce the odds of a false positive
           and thus reduce the number of useless heap visits, but of course also
           make the index larger and hence slower to scan.

           This type of index is most useful when a table has many attributes and
           queries test arbitrary combinations of them. A traditional btree index
           is faster than a bloom index, but it can require many btree indexes to
           support all possible queries where one needs only a single bloom index.
           Note however that bloom indexes only support equality queries, whereas
           btree indexes can also perform inequality and range searches.

        F.7.1. Parameters [14]#

           A bloom index accepts the following parameters in its WITH clause:

           length
                  Length of each signature (index entry) in bits. It is rounded up
                  to the nearest multiple of 16. The default is 80 bits and the
                  maximum is 4096.

           col1 -- col32
                  Number of bits generated for each index column. Each parameter's
                  name refers to the number of the index column that it controls.
                  The default is 2 bits and the maximum is 4095. Parameters for
                  index columns not actually used are ignored.

        F.7.2. Examples [15]#

           This is an example of creating a bloom index:
        CREATE INDEX bloomidx ON tbloom USING bloom (i1,i2,i3)
               WITH (length=80, col1=2, col2=2, col3=4);

           The index is created with a signature length of 80 bits, with
           attributes i1 and i2 mapped to 2 bits, and attribute i3 mapped to 4
           bits. We could have omitted the length, col1, and col2 specifications
           since those have the default values.

           Here is a more complete example of bloom index definition and usage, as
           well as a comparison with equivalent btree indexes. The bloom index is
           considerably smaller than the btree index, and can perform better.
        =# CREATE TABLE tbloom AS
           SELECT
             (random() * 1000000)::int as i1,
             (random() * 1000000)::int as i2,
             (random() * 1000000)::int as i3,
             (random() * 1000000)::int as i4,
             (random() * 1000000)::int as i5,
             (random() * 1000000)::int as i6
           FROM
          generate_series(1,10000000);
        SELECT 10000000

           A sequential scan over this large table takes a long time:
        =# EXPLAIN ANALYZE SELECT * FROM tbloom WHERE i2 = 898732 AND i5 = 123451;
                                                      QUERY PLAN
        --------------------------------------------------------------------------------
        ----------------------
         Seq Scan on tbloom  (cost=0.00..2137.14 rows=3 width=24) (actual time=16.971..1
        6.971 rows=0 loops=1)
           Filter: ((i2 = 898732) AND (i5 = 123451))
           Rows Removed by Filter: 100000
         Planning Time: 0.346 ms
         Execution Time: 16.988 ms
        (5 rows)

           Even with the btree index defined the result will still be a sequential
           scan:
        =# CREATE INDEX btreeidx ON tbloom (i1, i2, i3, i4, i5, i6);
        CREATE INDEX
        =# SELECT pg_size_pretty(pg_relation_size('btreeidx'));
         pg_size_pretty
        ----------------
         3976 kB
        (1 row)
        =# EXPLAIN ANALYZE SELECT * FROM tbloom WHERE i2 = 898732 AND i5 = 123451;
                                                      QUERY PLAN
        --------------------------------------------------------------------------------
        ----------------------
         Seq Scan on tbloom  (cost=0.00..2137.00 rows=2 width=24) (actual time=12.805..1
        2.805 rows=0 loops=1)
           Filter: ((i2 = 898732) AND (i5 = 123451))
           Rows Removed by Filter: 100000
         Planning Time: 0.138 ms
         Execution Time: 12.817 ms
        (5 rows)

           Having the bloom index defined on the table is better than btree in
           handling this type of search:
        =# CREATE INDEX bloomidx ON tbloom USING bloom (i1, i2, i3, i4, i5, i6);
        CREATE INDEX
        =# SELECT pg_size_pretty(pg_relation_size('bloomidx'));
         pg_size_pretty
        ----------------
         1584 kB
        (1 row)
        =# EXPLAIN ANALYZE SELECT * FROM tbloom WHERE i2 = 898732 AND i5 = 123451;
                                                             QUERY PLAN
        --------------------------------------------------------------------------------
        -------------------------------------
         Bitmap Heap Scan on tbloom  (cost=1792.00..1799.69 rows=2 width=24) (actual tim
        e=0.388..0.388 rows=0 loops=1)
           Recheck Cond: ((i2 = 898732) AND (i5 = 123451))
           Rows Removed by Index Recheck: 29
           Heap Blocks: exact=28
           ->  Bitmap Index Scan on bloomidx  (cost=0.00..1792.00 rows=2 width=0) (actua
        l time=0.356..0.356 rows=29 loops=1)
                 Index Cond: ((i2 = 898732) AND (i5 = 123451))
         Planning Time: 0.099 ms
         Execution Time: 0.408 ms
        (8 rows)

           Now, the main problem with the btree search is that btree is
           inefficient when the search conditions do not constrain the leading
           index column(s). A better strategy for btree is to create a separate
           index on each column. Then the planner will choose something like this:
        =# CREATE INDEX btreeidx1 ON tbloom (i1);
        CREATE INDEX
        =# CREATE INDEX btreeidx2 ON tbloom (i2);
        CREATE INDEX
        =# CREATE INDEX btreeidx3 ON tbloom (i3);
        CREATE INDEX
        =# CREATE INDEX btreeidx4 ON tbloom (i4);
        CREATE INDEX
        =# CREATE INDEX btreeidx5 ON tbloom (i5);
        CREATE INDEX
        =# CREATE INDEX btreeidx6 ON tbloom (i6);
        CREATE INDEX
        =# EXPLAIN ANALYZE SELECT * FROM tbloom WHERE i2 = 898732 AND i5 = 123451;
                                                                QUERY PLAN
        --------------------------------------------------------------------------------
        -------------------------------------------
         Bitmap Heap Scan on tbloom  (cost=24.34..32.03 rows=2 width=24) (actual time=0.
        028..0.029 rows=0 loops=1)
           Recheck Cond: ((i5 = 123451) AND (i2 = 898732))
           ->  BitmapAnd  (cost=24.34..24.34 rows=2 width=0) (actual time=0.027..0.027 r
        ows=0 loops=1)
                 ->  Bitmap Index Scan on btreeidx5  (cost=0.00..12.04 rows=500 width=0)
         (actual time=0.026..0.026 rows=0 loops=1)
                       Index Cond: (i5 = 123451)
                 ->  Bitmap Index Scan on btreeidx2  (cost=0.00..12.04 rows=500 width=0)
         (never executed)
                       Index Cond: (i2 = 898732)
         Planning Time: 0.491 ms
         Execution Time: 0.055 ms
        (9 rows)

           Although this query runs much faster than with either of the single
           indexes, we pay a penalty in index size. Each of the single-column
           btree indexes occupies 2 MB, so the total space needed is 12 MB, eight
           times the space used by the bloom index.

        F.7.3. Operator Class Interface [16]#

           An operator class for bloom indexes requires only a hash function for
           the indexed data type and an equality operator for searching. This
           example shows the operator class definition for the text data type:
        CREATE OPERATOR CLASS text_ops
        DEFAULT FOR TYPE text USING bloom AS
            OPERATOR    1   =(text, text),
            FUNCTION    1   hashtext(text);

        F.7.4. Limitations [17]#

             * Only operator classes for int4 and text are included with the
               module.
             * Only the = operator is supported for search. But it is possible to
               add support for arrays with union and intersection operations in
               the future.
             * bloom access method doesn't support UNIQUE indexes.
             * bloom access method doesn't support searching for NULL values.

        F.7.5. Authors [18]#

           Teodor Sigaev <[19]teodor@postgrespro.ru>, Postgres Professional,
           Moscow, Russia

           Alexander Korotkov <[20]a.korotkov@postgrespro.ru>, Postgres
           Professional, Moscow, Russia

           Oleg Bartunov <[21]obartunov@postgrespro.ru>, Postgres Professional,
           Moscow, Russia
             __________________________________________________________________

           [22]Prev                                              [23]Up   [24]Next
           F.6. basic_archive -- an example WAL archive module  [25]Home
           F.8. btree_gin -- GIN operator classes with B-tree behavior


        ```
    '15':
      source: https://ftp.postgresql.org/pub/source/v15.5/postgresql-15.5.tar.gz
      version: 15.5.0
      homepage: https://www.postgresql.org/docs/15/bloom.html
      readme: |
        For formatted documentation, please see https://www.postgresql.org/docs/15/bloom.html.

        ```
           #[1]F.6. basic_archive [2]F.8. btree_gin

                                         F.7. bloom
           [3]Prev  [4]Up Appendix F. Additional Supplied Modules [5]Home  [6]Next
             __________________________________________________________________

        F.7. bloom

           [7]F.7.1. Parameters
           [8]F.7.2. Examples
           [9]F.7.3. Operator Class Interface
           [10]F.7.4. Limitations
           [11]F.7.5. Authors

           bloom provides an index access method based on [12]Bloom filters.

           A Bloom filter is a space-efficient data structure that is used to test
           whether an element is a member of a set. In the case of an index access
           method, it allows fast exclusion of non-matching tuples via signatures
           whose size is determined at index creation.

           A signature is a lossy representation of the indexed attribute(s), and
           as such is prone to reporting false positives; that is, it may be
           reported that an element is in the set, when it is not. So index search
           results must always be rechecked using the actual attribute values from
           the heap entry. Larger signatures reduce the odds of a false positive
           and thus reduce the number of useless heap visits, but of course also
           make the index larger and hence slower to scan.

           This type of index is most useful when a table has many attributes and
           queries test arbitrary combinations of them. A traditional btree index
           is faster than a bloom index, but it can require many btree indexes to
           support all possible queries where one needs only a single bloom index.
           Note however that bloom indexes only support equality queries, whereas
           btree indexes can also perform inequality and range searches.

        F.7.1. Parameters

           A bloom index accepts the following parameters in its WITH clause:

           length
                  Length of each signature (index entry) in bits. It is rounded up
                  to the nearest multiple of 16. The default is 80 bits and the
                  maximum is 4096.

           col1 -- col32
                  Number of bits generated for each index column. Each parameter's
                  name refers to the number of the index column that it controls.
                  The default is 2 bits and the maximum is 4095. Parameters for
                  index columns not actually used are ignored.

        F.7.2. Examples

           This is an example of creating a bloom index:
        CREATE INDEX bloomidx ON tbloom USING bloom (i1,i2,i3)
               WITH (length=80, col1=2, col2=2, col3=4);

           The index is created with a signature length of 80 bits, with
           attributes i1 and i2 mapped to 2 bits, and attribute i3 mapped to 4
           bits. We could have omitted the length, col1, and col2 specifications
           since those have the default values.

           Here is a more complete example of bloom index definition and usage, as
           well as a comparison with equivalent btree indexes. The bloom index is
           considerably smaller than the btree index, and can perform better.
        =# CREATE TABLE tbloom AS
           SELECT
             (random() * 1000000)::int as i1,
             (random() * 1000000)::int as i2,
             (random() * 1000000)::int as i3,
             (random() * 1000000)::int as i4,
             (random() * 1000000)::int as i5,
             (random() * 1000000)::int as i6
           FROM
          generate_series(1,10000000);
        SELECT 10000000

           A sequential scan over this large table takes a long time:
        =# EXPLAIN ANALYZE SELECT * FROM tbloom WHERE i2 = 898732 AND i5 = 123451;
                                                      QUERY PLAN
        --------------------------------------------------------------------------------
        ----------------------
         Seq Scan on tbloom  (cost=0.00..2137.14 rows=3 width=24) (actual time=16.971..1
        6.971 rows=0 loops=1)
           Filter: ((i2 = 898732) AND (i5 = 123451))
           Rows Removed by Filter: 100000
         Planning Time: 0.346 ms
         Execution Time: 16.988 ms
        (5 rows)

           Even with the btree index defined the result will still be a sequential
           scan:
        =# CREATE INDEX btreeidx ON tbloom (i1, i2, i3, i4, i5, i6);
        CREATE INDEX
        =# SELECT pg_size_pretty(pg_relation_size('btreeidx'));
         pg_size_pretty
        ----------------
         3976 kB
        (1 row)
        =# EXPLAIN ANALYZE SELECT * FROM tbloom WHERE i2 = 898732 AND i5 = 123451;
                                                      QUERY PLAN
        --------------------------------------------------------------------------------
        ----------------------
         Seq Scan on tbloom  (cost=0.00..2137.00 rows=2 width=24) (actual time=12.805..1
        2.805 rows=0 loops=1)
           Filter: ((i2 = 898732) AND (i5 = 123451))
           Rows Removed by Filter: 100000
         Planning Time: 0.138 ms
         Execution Time: 12.817 ms
        (5 rows)

           Having the bloom index defined on the table is better than btree in
           handling this type of search:
        =# CREATE INDEX bloomidx ON tbloom USING bloom (i1, i2, i3, i4, i5, i6);
        CREATE INDEX
        =# SELECT pg_size_pretty(pg_relation_size('bloomidx'));
         pg_size_pretty
        ----------------
         1584 kB
        (1 row)
        =# EXPLAIN ANALYZE SELECT * FROM tbloom WHERE i2 = 898732 AND i5 = 123451;
                                                             QUERY PLAN
        --------------------------------------------------------------------------------
        -------------------------------------
         Bitmap Heap Scan on tbloom  (cost=1792.00..1799.69 rows=2 width=24) (actual tim
        e=0.388..0.388 rows=0 loops=1)
           Recheck Cond: ((i2 = 898732) AND (i5 = 123451))
           Rows Removed by Index Recheck: 29
           Heap Blocks: exact=28
           ->  Bitmap Index Scan on bloomidx  (cost=0.00..1792.00 rows=2 width=0) (actua
        l time=0.356..0.356 rows=29 loops=1)
                 Index Cond: ((i2 = 898732) AND (i5 = 123451))
         Planning Time: 0.099 ms
         Execution Time: 0.408 ms
        (8 rows)

           Now, the main problem with the btree search is that btree is
           inefficient when the search conditions do not constrain the leading
           index column(s). A better strategy for btree is to create a separate
           index on each column. Then the planner will choose something like this:
        =# CREATE INDEX btreeidx1 ON tbloom (i1);
        CREATE INDEX
        =# CREATE INDEX btreeidx2 ON tbloom (i2);
        CREATE INDEX
        =# CREATE INDEX btreeidx3 ON tbloom (i3);
        CREATE INDEX
        =# CREATE INDEX btreeidx4 ON tbloom (i4);
        CREATE INDEX
        =# CREATE INDEX btreeidx5 ON tbloom (i5);
        CREATE INDEX
        =# CREATE INDEX btreeidx6 ON tbloom (i6);
        CREATE INDEX
        =# EXPLAIN ANALYZE SELECT * FROM tbloom WHERE i2 = 898732 AND i5 = 123451;
                                                                QUERY PLAN
        --------------------------------------------------------------------------------
        -------------------------------------------
         Bitmap Heap Scan on tbloom  (cost=24.34..32.03 rows=2 width=24) (actual time=0.
        028..0.029 rows=0 loops=1)
           Recheck Cond: ((i5 = 123451) AND (i2 = 898732))
           ->  BitmapAnd  (cost=24.34..24.34 rows=2 width=0) (actual time=0.027..0.027 r
        ows=0 loops=1)
                 ->  Bitmap Index Scan on btreeidx5  (cost=0.00..12.04 rows=500 width=0)
         (actual time=0.026..0.026 rows=0 loops=1)
                       Index Cond: (i5 = 123451)
                 ->  Bitmap Index Scan on btreeidx2  (cost=0.00..12.04 rows=500 width=0)
         (never executed)
                       Index Cond: (i2 = 898732)
         Planning Time: 0.491 ms
         Execution Time: 0.055 ms
        (9 rows)

           Although this query runs much faster than with either of the single
           indexes, we pay a penalty in index size. Each of the single-column
           btree indexes occupies 2 MB, so the total space needed is 12 MB, eight
           times the space used by the bloom index.

        F.7.3. Operator Class Interface

           An operator class for bloom indexes requires only a hash function for
           the indexed data type and an equality operator for searching. This
           example shows the operator class definition for the text data type:
        CREATE OPERATOR CLASS text_ops
        DEFAULT FOR TYPE text USING bloom AS
            OPERATOR    1   =(text, text),
            FUNCTION    1   hashtext(text);

        F.7.4. Limitations

             * Only operator classes for int4 and text are included with the
               module.
             * Only the = operator is supported for search. But it is possible to
               add support for arrays with union and intersection operations in
               the future.
             * bloom access method doesn't support UNIQUE indexes.
             * bloom access method doesn't support searching for NULL values.

        F.7.5. Authors

           Teodor Sigaev <[13]teodor@postgrespro.ru>, Postgres Professional,
           Moscow, Russia

           Alexander Korotkov <[14]a.korotkov@postgrespro.ru>, Postgres
           Professional, Moscow, Russia

           Oleg Bartunov <[15]obartunov@postgrespro.ru>, Postgres Professional,
           Moscow, Russia
             __________________________________________________________________

           [16]Prev             [17]Up         [18]Next
           F.6. basic_archive  [19]Home  F.8. btree_gin


        ```
    '14':
      source: https://ftp.postgresql.org/pub/source/v14.10/postgresql-14.10.tar.gz
      version: 14.10.0
      homepage: https://www.postgresql.org/docs/14/bloom.html
      readme: |
        For formatted documentation, please see https://www.postgresql.org/docs/14/bloom.html.

        ```
           #[1]F.4. auto_explain [2]F.6. btree_gin

                                         F.5. bloom
           [3]Prev  [4]Up Appendix F. Additional Supplied Modules [5]Home  [6]Next
             __________________________________________________________________

        F.5. bloom

           [7]F.5.1. Parameters
           [8]F.5.2. Examples
           [9]F.5.3. Operator Class Interface
           [10]F.5.4. Limitations
           [11]F.5.5. Authors

           bloom provides an index access method based on [12]Bloom filters.

           A Bloom filter is a space-efficient data structure that is used to test
           whether an element is a member of a set. In the case of an index access
           method, it allows fast exclusion of non-matching tuples via signatures
           whose size is determined at index creation.

           A signature is a lossy representation of the indexed attribute(s), and
           as such is prone to reporting false positives; that is, it may be
           reported that an element is in the set, when it is not. So index search
           results must always be rechecked using the actual attribute values from
           the heap entry. Larger signatures reduce the odds of a false positive
           and thus reduce the number of useless heap visits, but of course also
           make the index larger and hence slower to scan.

           This type of index is most useful when a table has many attributes and
           queries test arbitrary combinations of them. A traditional btree index
           is faster than a bloom index, but it can require many btree indexes to
           support all possible queries where one needs only a single bloom index.
           Note however that bloom indexes only support equality queries, whereas
           btree indexes can also perform inequality and range searches.

        F.5.1. Parameters

           A bloom index accepts the following parameters in its WITH clause:

           length
                  Length of each signature (index entry) in bits. It is rounded up
                  to the nearest multiple of 16. The default is 80 bits and the
                  maximum is 4096.

           col1 -- col32
                  Number of bits generated for each index column. Each parameter's
                  name refers to the number of the index column that it controls.
                  The default is 2 bits and the maximum is 4095. Parameters for
                  index columns not actually used are ignored.

        F.5.2. Examples

           This is an example of creating a bloom index:
        CREATE INDEX bloomidx ON tbloom USING bloom (i1,i2,i3)
               WITH (length=80, col1=2, col2=2, col3=4);

           The index is created with a signature length of 80 bits, with
           attributes i1 and i2 mapped to 2 bits, and attribute i3 mapped to 4
           bits. We could have omitted the length, col1, and col2 specifications
           since those have the default values.

           Here is a more complete example of bloom index definition and usage, as
           well as a comparison with equivalent btree indexes. The bloom index is
           considerably smaller than the btree index, and can perform better.
        =# CREATE TABLE tbloom AS
           SELECT
             (random() * 1000000)::int as i1,
             (random() * 1000000)::int as i2,
             (random() * 1000000)::int as i3,
             (random() * 1000000)::int as i4,
             (random() * 1000000)::int as i5,
             (random() * 1000000)::int as i6
           FROM
          generate_series(1,10000000);
        SELECT 10000000

           A sequential scan over this large table takes a long time:
        =# EXPLAIN ANALYZE SELECT * FROM tbloom WHERE i2 = 898732 AND i5 = 123451;
                                                      QUERY PLAN

        --------------------------------------------------------------------------------
        ----------------------
         Seq Scan on tbloom  (cost=0.00..2137.14 rows=3 width=24) (actual time=16.971..1
        6.971 rows=0 loops=1)
           Filter: ((i2 = 898732) AND (i5 = 123451))
           Rows Removed by Filter: 100000
         Planning Time: 0.346 ms
         Execution Time: 16.988 ms
        (5 rows)

           Even with the btree index defined the result will still be a sequential
           scan:
        =# CREATE INDEX btreeidx ON tbloom (i1, i2, i3, i4, i5, i6);
        CREATE INDEX
        =# SELECT pg_size_pretty(pg_relation_size('btreeidx'));
         pg_size_pretty
        ----------------
         3976 kB
        (1 row)
        =# EXPLAIN ANALYZE SELECT * FROM tbloom WHERE i2 = 898732 AND i5 = 123451;
                                                      QUERY PLAN

        --------------------------------------------------------------------------------
        ----------------------
         Seq Scan on tbloom  (cost=0.00..2137.00 rows=2 width=24) (actual time=12.805..1
        2.805 rows=0 loops=1)
           Filter: ((i2 = 898732) AND (i5 = 123451))
           Rows Removed by Filter: 100000
         Planning Time: 0.138 ms
         Execution Time: 12.817 ms
        (5 rows)

           Having the bloom index defined on the table is better than btree in
           handling this type of search:
        =# CREATE INDEX bloomidx ON tbloom USING bloom (i1, i2, i3, i4, i5, i6);
        CREATE INDEX
        =# SELECT pg_size_pretty(pg_relation_size('bloomidx'));
         pg_size_pretty
        ----------------
         1584 kB
        (1 row)
        =# EXPLAIN ANALYZE SELECT * FROM tbloom WHERE i2 = 898732 AND i5 = 123451;
                                                             QUERY PLAN

        --------------------------------------------------------------------------------
        -------------------------------------
         Bitmap Heap Scan on tbloom  (cost=1792.00..1799.69 rows=2 width=24) (actual tim
        e=0.388..0.388 rows=0 loops=1)
           Recheck Cond: ((i2 = 898732) AND (i5 = 123451))
           Rows Removed by Index Recheck: 29
           Heap Blocks: exact=28
           ->  Bitmap Index Scan on bloomidx  (cost=0.00..1792.00 rows=2 width=0) (actua
        l time=0.356..0.356 rows=29 loops=1)
                 Index Cond: ((i2 = 898732) AND (i5 = 123451))
         Planning Time: 0.099 ms
         Execution Time: 0.408 ms
        (8 rows)

           Now, the main problem with the btree search is that btree is
           inefficient when the search conditions do not constrain the leading
           index column(s). A better strategy for btree is to create a separate
           index on each column. Then the planner will choose something like this:
        =# CREATE INDEX btreeidx1 ON tbloom (i1);
        CREATE INDEX
        =# CREATE INDEX btreeidx2 ON tbloom (i2);
        CREATE INDEX
        =# CREATE INDEX btreeidx3 ON tbloom (i3);
        CREATE INDEX
        =# CREATE INDEX btreeidx4 ON tbloom (i4);
        CREATE INDEX
        =# CREATE INDEX btreeidx5 ON tbloom (i5);
        CREATE INDEX
        =# CREATE INDEX btreeidx6 ON tbloom (i6);
        CREATE INDEX
        =# EXPLAIN ANALYZE SELECT * FROM tbloom WHERE i2 = 898732 AND i5 = 123451;
                                                                QUERY PLAN

        --------------------------------------------------------------------------------
        -------------------------------------------
         Bitmap Heap Scan on tbloom  (cost=24.34..32.03 rows=2 width=24) (actual time=0.
        028..0.029 rows=0 loops=1)
           Recheck Cond: ((i5 = 123451) AND (i2 = 898732))
           ->  BitmapAnd  (cost=24.34..24.34 rows=2 width=0) (actual time=0.027..0.027 r
        ows=0 loops=1)
                 ->  Bitmap Index Scan on btreeidx5  (cost=0.00..12.04 rows=500 width=0)
         (actual time=0.026..0.026 rows=0 loops=1)
                       Index Cond: (i5 = 123451)
                 ->  Bitmap Index Scan on btreeidx2  (cost=0.00..12.04 rows=500 width=0)
         (never executed)
                       Index Cond: (i2 = 898732)
         Planning Time: 0.491 ms
         Execution Time: 0.055 ms
        (9 rows)

           Although this query runs much faster than with either of the single
           indexes, we pay a penalty in index size. Each of the single-column
           btree indexes occupies 2 MB, so the total space needed is 12 MB, eight
           times the space used by the bloom index.

        F.5.3. Operator Class Interface

           An operator class for bloom indexes requires only a hash function for
           the indexed data type and an equality operator for searching. This
           example shows the operator class definition for the text data type:
        CREATE OPERATOR CLASS text_ops
        DEFAULT FOR TYPE text USING bloom AS
            OPERATOR    1   =(text, text),
            FUNCTION    1   hashtext(text);

        F.5.4. Limitations

             * Only operator classes for int4 and text are included with the
               module.
             * Only the = operator is supported for search. But it is possible to
               add support for arrays with union and intersection operations in
               the future.
             * bloom access method doesn't support UNIQUE indexes.
             * bloom access method doesn't support searching for NULL values.

        F.5.5. Authors

           Teodor Sigaev <[13]teodor@postgrespro.ru>, Postgres Professional,
           Moscow, Russia

           Alexander Korotkov <[14]a.korotkov@postgrespro.ru>, Postgres
           Professional, Moscow, Russia

           Oleg Bartunov <[15]obartunov@postgrespro.ru>, Postgres Professional,
           Moscow, Russia
             __________________________________________________________________

           [16]Prev            [17]Up         [18]Next
           F.4. auto_explain  [19]Home  F.6. btree_gin


        ```
    '13':
      source: https://ftp.postgresql.org/pub/source/v13.13/postgresql-13.13.tar.gz
      version: 13.13.0
      homepage: https://www.postgresql.org/docs/13/bloom.html
      readme: |
        For formatted documentation, please see https://www.postgresql.org/docs/13/bloom.html.

        ```
           #[1]F.4. auto_explain [2]F.6. btree_gin

                                         F.5. bloom
           [3]Prev  [4]Up Appendix F. Additional Supplied Modules [5]Home  [6]Next
             __________________________________________________________________

        F.5. bloom

           [7]F.5.1. Parameters
           [8]F.5.2. Examples
           [9]F.5.3. Operator Class Interface
           [10]F.5.4. Limitations
           [11]F.5.5. Authors

           bloom provides an index access method based on [12]Bloom filters.

           A Bloom filter is a space-efficient data structure that is used to test
           whether an element is a member of a set. In the case of an index access
           method, it allows fast exclusion of non-matching tuples via signatures
           whose size is determined at index creation.

           A signature is a lossy representation of the indexed attribute(s), and
           as such is prone to reporting false positives; that is, it may be
           reported that an element is in the set, when it is not. So index search
           results must always be rechecked using the actual attribute values from
           the heap entry. Larger signatures reduce the odds of a false positive
           and thus reduce the number of useless heap visits, but of course also
           make the index larger and hence slower to scan.

           This type of index is most useful when a table has many attributes and
           queries test arbitrary combinations of them. A traditional btree index
           is faster than a bloom index, but it can require many btree indexes to
           support all possible queries where one needs only a single bloom index.
           Note however that bloom indexes only support equality queries, whereas
           btree indexes can also perform inequality and range searches.

        F.5.1. Parameters

           A bloom index accepts the following parameters in its WITH clause:

           length
                  Length of each signature (index entry) in bits. It is rounded up
                  to the nearest multiple of 16. The default is 80 bits and the
                  maximum is 4096.

           col1 -- col32
                  Number of bits generated for each index column. Each parameter's
                  name refers to the number of the index column that it controls.
                  The default is 2 bits and the maximum is 4095. Parameters for
                  index columns not actually used are ignored.

        F.5.2. Examples

           This is an example of creating a bloom index:
        CREATE INDEX bloomidx ON tbloom USING bloom (i1,i2,i3)
               WITH (length=80, col1=2, col2=2, col3=4);

           The index is created with a signature length of 80 bits, with
           attributes i1 and i2 mapped to 2 bits, and attribute i3 mapped to 4
           bits. We could have omitted the length, col1, and col2 specifications
           since those have the default values.

           Here is a more complete example of bloom index definition and usage, as
           well as a comparison with equivalent btree indexes. The bloom index is
           considerably smaller than the btree index, and can perform better.
        =# CREATE TABLE tbloom AS
           SELECT
             (random() * 1000000)::int as i1,
             (random() * 1000000)::int as i2,
             (random() * 1000000)::int as i3,
             (random() * 1000000)::int as i4,
             (random() * 1000000)::int as i5,
             (random() * 1000000)::int as i6
           FROM
          generate_series(1,10000000);
        SELECT 10000000

           A sequential scan over this large table takes a long time:
        =# EXPLAIN ANALYZE SELECT * FROM tbloom WHERE i2 = 898732 AND i5 = 123451;
                                                      QUERY PLAN

        --------------------------------------------------------------------------------
        ----------------------
         Seq Scan on tbloom  (cost=0.00..2137.14 rows=3 width=24) (actual time=15.480..1
        5.480 rows=0 loops=1)
           Filter: ((i2 = 898732) AND (i5 = 123451))
           Rows Removed by Filter: 100000
         Planning Time: 0.340 ms
         Execution Time: 15.501 ms
        (5 rows)

           Even with the btree index defined the result will still be a sequential
           scan:
        =# CREATE INDEX btreeidx ON tbloom (i1, i2, i3, i4, i5, i6);
        CREATE INDEX
        =# SELECT pg_size_pretty(pg_relation_size('btreeidx'));
         pg_size_pretty
        ----------------
         3976 kB
        (1 row)
        =# EXPLAIN ANALYZE SELECT * FROM tbloom WHERE i2 = 898732 AND i5 = 123451;
                                                      QUERY PLAN

        --------------------------------------------------------------------------------
        ----------------------
         Seq Scan on tbloom  (cost=0.00..2137.00 rows=2 width=24) (actual time=12.604..1
        2.604 rows=0 loops=1)
           Filter: ((i2 = 898732) AND (i5 = 123451))
           Rows Removed by Filter: 100000
         Planning Time: 0.155 ms
         Execution Time: 12.617 ms
        (5 rows)

           Having the bloom index defined on the table is better than btree in
           handling this type of search:
        =# CREATE INDEX bloomidx ON tbloom USING bloom (i1, i2, i3, i4, i5, i6);
        CREATE INDEX
        =# SELECT pg_size_pretty(pg_relation_size('bloomidx'));
         pg_size_pretty
        ----------------
         1584 kB
        (1 row)
        =# EXPLAIN ANALYZE SELECT * FROM tbloom WHERE i2 = 898732 AND i5 = 123451;
                                                             QUERY PLAN

        --------------------------------------------------------------------------------
        -------------------------------------
         Bitmap Heap Scan on tbloom  (cost=1792.00..1799.69 rows=2 width=24) (actual tim
        e=0.384..0.384 rows=0 loops=1)
           Recheck Cond: ((i2 = 898732) AND (i5 = 123451))
           Rows Removed by Index Recheck: 26
           Heap Blocks: exact=26
           ->  Bitmap Index Scan on bloomidx  (cost=0.00..1792.00 rows=2 width=0) (actua
        l time=0.350..0.350 rows=26 loops=1)
                 Index Cond: ((i2 = 898732) AND (i5 = 123451))
         Planning Time: 0.122 ms
         Execution Time: 0.407 ms
        (8 rows)

           Now, the main problem with the btree search is that btree is
           inefficient when the search conditions do not constrain the leading
           index column(s). A better strategy for btree is to create a separate
           index on each column. Then the planner will choose something like this:
        =# CREATE INDEX btreeidx1 ON tbloom (i1);
        CREATE INDEX
        =# CREATE INDEX btreeidx2 ON tbloom (i2);
        CREATE INDEX
        =# CREATE INDEX btreeidx3 ON tbloom (i3);
        CREATE INDEX
        =# CREATE INDEX btreeidx4 ON tbloom (i4);
        CREATE INDEX
        =# CREATE INDEX btreeidx5 ON tbloom (i5);
        CREATE INDEX
        =# CREATE INDEX btreeidx6 ON tbloom (i6);
        CREATE INDEX
        =# EXPLAIN ANALYZE SELECT * FROM tbloom WHERE i2 = 898732 AND i5 = 123451;
                                                                QUERY PLAN

        --------------------------------------------------------------------------------
        -------------------------------------------
         Bitmap Heap Scan on tbloom  (cost=24.34..32.03 rows=2 width=24) (actual time=0.
        032..0.033 rows=0 loops=1)
           Recheck Cond: ((i5 = 123451) AND (i2 = 898732))
           ->  BitmapAnd  (cost=24.34..24.34 rows=2 width=0) (actual time=0.029..0.030 r
        ows=0 loops=1)
                 ->  Bitmap Index Scan on btreeidx5  (cost=0.00..12.04 rows=500 width=0)
         (actual time=0.029..0.029 rows=0 loops=1)
                       Index Cond: (i5 = 123451)
                 ->  Bitmap Index Scan on btreeidx2  (cost=0.00..12.04 rows=500 width=0)
         (never executed)
                       Index Cond: (i2 = 898732)
         Planning Time: 0.537 ms
         Execution Time: 0.064 ms
        (9 rows)

           Although this query runs much faster than with either of the single
           indexes, we pay a penalty in index size. Each of the single-column
           btree indexes occupies 2 MB, so the total space needed is 12 MB, eight
           times the space used by the bloom index.

        F.5.3. Operator Class Interface

           An operator class for bloom indexes requires only a hash function for
           the indexed data type and an equality operator for searching. This
           example shows the operator class definition for the text data type:
        CREATE OPERATOR CLASS text_ops
        DEFAULT FOR TYPE text USING bloom AS
            OPERATOR    1   =(text, text),
            FUNCTION    1   hashtext(text);

        F.5.4. Limitations

             * Only operator classes for int4 and text are included with the
               module.
             * Only the = operator is supported for search. But it is possible to
               add support for arrays with union and intersection operations in
               the future.
             * bloom access method doesn't support UNIQUE indexes.
             * bloom access method doesn't support searching for NULL values.

        F.5.5. Authors

           Teodor Sigaev <[13]teodor@postgrespro.ru>, Postgres Professional,
           Moscow, Russia

           Alexander Korotkov <[14]a.korotkov@postgrespro.ru>, Postgres
           Professional, Moscow, Russia

           Oleg Bartunov <[15]obartunov@postgrespro.ru>, Postgres Professional,
           Moscow, Russia
             __________________________________________________________________

           [16]Prev            [17]Up         [18]Next
           F.4. auto_explain  [19]Home  F.6. btree_gin


        ```
pgVersions:
- '16'
- '15'
- '14'
- '13'
